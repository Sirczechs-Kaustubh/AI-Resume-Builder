from flask import Flask, request, Response, render_template_string, redirect, url_for, session
import yaml
from jinja2 import Environment, FileSystemLoader
import os
import subprocess
from groq import Groq
import json
import secret

app = Flask(__name__)
app.secret_key = secret.session_key  # Needed for session management

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        if 'yaml_data' in request.form:
            yaml_data = request.form['yaml_data']
            session['yaml_data'] = yaml_data  # Store data in session
            return redirect(url_for('process_data'))
        elif 'file' in request.files:
            file = request.files['file']
            yaml_data = yaml.safe_load(file.stream)
            session['yaml_data'] = str(yaml_data)  # Store data in session as a string
            return redirect(url_for('process_data'))
    return render_template_string('''
        <html><body>
        <h2>Enter Your YAML Data</h2>
        <form action="/" method="post">
          <textarea name="yaml_data" cols="100" rows="20"></textarea><br>
          <input type="submit" value="Submit">
          <input type="submit" name="action" value="Download" formaction="/download">
        </form>
        <h2>Or Upload a YAML File</h2>
        <form action="/" method="post" enctype="multipart/form-data">
          <input type="file" name="file">
          <input type="submit" value="Read">
        </form>
        </body></html>
    ''')

@app.route('/download', methods=['POST'])
def download_yaml():
    yaml_data = request.form['yaml_data']
    response = Response(yaml_data, mimetype='text/yaml')
    response.headers['Content-Disposition'] = 'attachment; filename="submitted_data.yaml"'
    return response

@app.route('/process_data', methods=['GET', 'POST'])
def process_data():
    if request.method == 'POST':
        jd = request.form['jd']
        # Store JD in session along with YAML data to maintain state across requests
        session['jd'] = jd
        # Redirect to final_page that will use the data stored in session
        return redirect(url_for('final_page'))

    # Check if YAML data exists in the session and display form for entering JD
    yaml_data = session.get('yaml_data', '')
    if yaml_data == '':
        # If no YAML data in session, redirect to start to ensure flow integrity
        return redirect(url_for('index'))

    return render_template_string('''
        <html><body>
        <h2>Enter Job Description</h2>
        <form action="/process_data" method="post">
          <textarea name="jd" cols="100" rows="10"></textarea><br>
          <button type="submit">Submit JD</button>
        </form>
        </body></html>
    ''')


    
    
def render_resume(data_file, template_file):
  """Renders a LaTeX resume using Jinja2 templating.

  Args:
      data_file (str): Path to the YAML data file.
      template_file (str): Path to the Jinja2 template file.

  Returns:
      str: The rendered LaTeX resume content.
  """
  env = Environment(
      block_start_string='~<',
      block_end_string='>~',
      variable_start_string='<<',
      variable_end_string='>>',
      comment_start_string='<#',
      comment_end_string='#>',
      trim_blocks=True,
      lstrip_blocks=True,
      loader=FileSystemLoader(searchpath="./"),
  )

  with open(data_file, "r") as fin:
    resume = yaml.safe_load(fin)

  template = env.get_template(template_file)
  return template.render(resume)

def save_latex(rendered_content, output_folder, filename):
  """Saves the rendered LaTeX content to a file.

  Args:
      rendered_content (str): The rendered LaTeX content.
      output_folder (str): Path to the output folder.
      filename (str): Name of the output file (excluding extension).
  """
  os.makedirs(output_folder, exist_ok=True)

  output_path = os.path.join(output_folder, f"{filename}_resume.tex")
  with open(output_path, "w") as fout:
    fout.write(rendered_content)


def compile_pdf(filename, output_folder):
  """Compiles the LaTeX file to a PDF using pdflatex.

  Args:
      filename (str): Name of the LaTeX file (excluding extension).
      output_folder (str): Path to the output folder.

  Raises:
      FileNotFoundError: If pdflatex is not found.
  """
  try:
    subprocess.run(["pdflatex", f"{filename}_resume.tex"], cwd=output_folder)
    print("PDF compilation successful!")
  except FileNotFoundError:
    print("Error: pdflatex command not found. Make sure it's installed.")


def clean_auxiliary_files(filename, output_folder):
  """Cleans up auxiliary files generated by LaTeX compilation.

  Args:
      filename (str): Name of the LaTeX file (excluding extension).
      output_folder (str): Path to the output folder.
  """
  for ext in ['aux', 'log', 'out']:
    aux_file = os.path.join(output_folder, f"{filename}_resume.{ext}")
    if os.path.isfile(aux_file):
      os.remove(aux_file)
      
def generate_resume(data_file, template_file, output_folder):
  """Generates a LaTeX resume and compiles it to PDF.

  Args:
      data_file (str): Path to the YAML data file.
      template_file (str): Path to the Jinja2 template file.
      output_folder (str): Path to the output folder.
  """
  rendered_content = render_resume(data_file, template_file)
  filename = os.path.splitext(os.path.basename(data_file))[0]  # Extract filename without extension
  save_latex(rendered_content, output_folder, filename)
  compile_pdf(filename, output_folder)
  clean_auxiliary_files(filename, output_folder)
  print(f"Resume saved to {os.path.join(output_folder, filename)}_resume.tex")


experience_details = {}
def llama_call(data, jd):
    yaml_data = yaml.safe_load(data)
    try:
        if 'experience' in yaml_data:
            for entry in yaml_data["experience"]:
                experience_details[entry["company"]] = entry["details"]

        if 'leadership' in yaml_data:
            for entry in yaml_data['leadership']:
                experience_details[entry["organization"]] = entry["details"]
                
        client = Groq(api_key=secret.api_key) 
        jd_string = "Job Description:\n" + jd
        resume_details = json.dumps(experience_details, indent=2)
        prompt_message = f"""Objective: Generate tailored resume content.
Input Specifications:
- Job Description: Detailed description including required skills and responsibilities.
- Candidate's Basic Experience: Provided as JSON-formatted resume details.

Output Specifications:
- Resume Details Section: Generate targeted bullet points for each company and organization, tailored to the job description. Limit to 3-4 bullet points per company detail.
- Skills Sections: Extract and list technical and soft skills as mentioned in the job description.

Instructions:
Based on the provided job description and candidate's experience and leadership experience, generate a structured JSON output containing tailored resume details for all the sections of resume and relevant skills sections."""

        messages = [
            {"role": "system", "content": prompt_message},
            {"role": "user", "content": f"Job Description:\n{jd}\n\nCandidate's Basic Experience:\n{resume_details}"}
        ]
        completion = client.chat.completions.create(
            model="llama3-70b-8192",
            messages= messages,
            temperature=0.85,
            max_tokens=1830,
            top_p=1,
            stream=False,
            response_format={"type": "json_object"},
            stop=None,
        )
        gen_text = completion.choices[0].message
        json_content = json.loads(gen_text.content)  # Assuming that the output is in JSON string format
        print(json_content)
        if "experience" in yaml_data:
            for section in yaml_data["experience"]:
                company = section['company']
                print(company)
                if company in json_content["Resume Details"]:
                    details = json_content["Resume Details"]  # Corrected key access
                    if company in details:  # Check if company exists before accessing details
                        print("hell yes 1")
                        section["details"]=details[company]
			
        if "leadership" in yaml_data:
            for section in yaml_data["leadership"]:
                    org = section['organization']
                    if org in json_content["Resume Details"]:
                            detail = json_content['Resume Details'][org]
                            if detail and len(detail)>0:
                                section["details"] = detail
                                print("hell yes 2")
			
        if "skills" in yaml_data:
          if isinstance(yaml_data, dict):
            yaml_data["skills"] = json_content["Skills"].copy()  # Replace skills with a copy
          else:
            print("Error: resume_details is not a dictionary. Cannot assign skills.")
        else:
              yaml_data["skills"] = json_content["Skills"].copy()  # Add skills with a copy

        print(yaml_data)

	
        
        

    except Exception as e:
        print(f"An error occurred: {str(e)}")



@app.route('/final_page', methods=['GET'])
def final_page():
    yaml_data = session.get('yaml_data', '')
    jd = session.get('jd', '')
    llama_call(data=yaml_data,jd=jd)
    return render_template_string('''
        <html><body>
        <h3>YAML Data:</h3>
        <pre>{{ yaml_data }}</pre>
        <h3>Job Description:</h3>
        <pre>{{ jd }}</pre>
        </body></html>
    ''', yaml_data=yaml_data, jd=jd)


  
@app.route('/generate-resume', methods=['POST'])
def generate_resume_route():
  data_file = request.form.get('data_file')
  template_file = request.form.get('template_file')
  output_folder = 'output'  # Assuming a static output folder
  generate_resume(data_file, template_file, output_folder)
  return render_template('success.html')  # Display success message



if __name__ == '__main__':
    app.run(debug=True)
